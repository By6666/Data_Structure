//中序法->后序法
//1、从左到右读进中序表达式的每个字符
//2、如果读进的字符为操作数，则直接输出到后序表达式中
//3、如果遇到“）”，则弹出堆栈内的运算符，直到弹出到一个“（”，两者相互抵消
//4、“（”的优先级在堆栈内比任何运算符都小，任何运算符的优先级都可压过它，不过在栈外他的优先级是最高的
//5、当运算符准备进入堆栈内时，必须金额堆栈顶端的运算符比较，如果外面运算符的优先级高于堆栈顶端的运算符则压入堆栈，否则就
//   弹出栈顶的运算符直到栈顶的运算符优先级小于外面的运算符优先级或者堆栈为空时，就压入外面这个运算符
//6、中序法表达式读完后，如果堆栈不是空的，则将其中的运算符逐一弹出，最后输出结果即可

#include "Stack.h"
#include "Operator.h"

int main()
{
	string result_of_change;

//*****中序->后序*****
	result_of_change = change_to_postofix();

	cout << endl;

//********运算********
	Caculator(result_of_change);
	system("pause");
	return 0;
}